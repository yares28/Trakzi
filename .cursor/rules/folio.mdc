# Cursor Project Rules – Folio (github.com/yares28/Folio)

Context file for Cursor AI assistant. Auto-loaded at conversation start.

## Priority Order

**All changes must satisfy (in order):**
1. **Security** — No vulnerabilities, data leaks, or unauthorized access
2. **Scalability** — Queries, components, APIs must handle 100K+ rows/users
3. **UX** — Responsive, fluid, no bugs or layout shifts

> [!CAUTION]
> Push back on any solution that is inefficient or won't scale. Propose alternatives.

## Quick Reference

### Commands
```bash
npm run dev       # Dev server (localhost:3000)
npm run build     # Production build — ALWAYS run before completing tasks
npm run lint      # ESLint
npm test          # Jest tests
```

### Key Files
| Purpose | Location |
|---------|----------|
| DB queries | `lib/neonClient.ts` → `neonQuery()`, `neonInsert()` |
| Auth | `lib/auth.ts` → `getCurrentUserId()` |
| Subscriptions | `lib/subscriptions.ts` |
| Types | `lib/types/` or `types/` |
| API routes | `app/api/` |
| Tests | `__tests__/` (mirrors source structure) |
| Schema docs | `docs/CORE/NEON_DATABASE.md` |

### Terminology
- **Trakzi / Folio** = Product names (same app)
- **Fridge** = Receipt/grocery tracking section
- **Statement** = Imported bank CSV file
- **Bundle API** = Aggregated chart endpoints (e.g., `home-bundle`, `fridge-bundle`)

## Stack

- **Next.js 16** (App Router, React 19)
- **Tailwind CSS v4** + shadcn/ui
- **Neon Postgres** via `@neondatabase/serverless` (raw SQL, no Prisma)
- **Clerk** auth → synced to Neon `users` table
- **Stripe** subscriptions → webhooks at `/api/webhook/stripe`
- **Upstash Redis** → caching, rate limiting
- **PostHog** → analytics

### Three-System Identity
```
Clerk userId (primary) ←→ Neon users.user_id ←→ Stripe customer.metadata.userId
```
Neon is source of truth for subscription status.

## Patterns

### Database Access
```typescript
import { neonQuery } from '@/lib/neonClient'
// ALWAYS include user_id filter
const rows = await neonQuery<T>('SELECT * FROM table WHERE user_id = $1', [userId])
```

### API Authentication
```typescript
import { getCurrentUserId } from '@/lib/auth'

export async function GET() {
  const userId = await getCurrentUserId() // Throws 401 if not authenticated
  // Use userId in ALL queries
}
```

### Page Structure
```
app/
  [page]/
    page.tsx           # Route entry
    _page/             # Page-specific components, hooks, utils
```

## Chart Bundles & Caching (IMPORTANT)

Every page loads chart data via a **single bundle API** that aggregates all charts and caches with **Upstash Redis**.

### Bundle Routes by Page

| Page | Bundle API | Aggregation File | Cache Prefix |
|------|------------|------------------|--------------|
| Home | `/api/charts/home-bundle` | `lib/charts/home-trends-savings-aggregations.ts` | `home` |
| Analytics | `/api/charts/analytics-bundle` | `lib/charts/aggregations.ts` | `analytics` |
| Fridge | `/api/charts/fridge-bundle` | `lib/charts/fridge-aggregations.ts` | `fridge` |
| Trends | `/api/charts/trends-bundle` | `lib/charts/home-trends-savings-aggregations.ts` | `trends` |
| Savings | `/api/charts/savings-bundle` | `lib/charts/home-trends-savings-aggregations.ts` | `savings` |
| Data Library | `/api/charts/data-library-bundle` | — | `data-library` |
| Test Charts | `/api/charts/test-charts-bundle` | `lib/charts/aggregations.ts` | `test-charts` |

### When Adding or Updating Charts

> [!IMPORTANT]
> **Always bundle chart data and cache it.** Never fetch chart data with individual API calls.

1. **Add chart data to the aggregation file** (e.g., `lib/charts/aggregations.ts`)
2. **Include it in the bundle's Summary type** (e.g., `AnalyticsSummary`)
3. **Return it from the bundle function** (e.g., `getAnalyticsBundle()`)
4. **Cache is automatic** via `getCachedOrCompute()`

### Cache Pattern
```typescript
import { getCachedOrCompute, buildCacheKey, CACHE_TTL } from '@/lib/cache/upstash'

// In bundle route:
const cacheKey = buildCacheKey('analytics', userId, filter, 'bundle')
const data = await getCachedOrCompute<AnalyticsSummary>(
    cacheKey,
    () => getAnalyticsBundle(userId, filter),
    CACHE_TTL.analytics  // 5 minutes
)
```

### Cache Invalidation
When data changes (upload, edit, delete), invalidate the relevant cache:
```typescript
import { invalidateUserCachePrefix } from '@/lib/cache/upstash'

// After mutation:
await invalidateUserCachePrefix(userId, 'analytics')
await invalidateUserCachePrefix(userId, 'home')
```

### Cache TTLs (`lib/cache/upstash.ts`)
- `analytics` / `fridge` / `test-charts`: 5 minutes
- `categories`: 30 minutes
- `short`: 1 minute

## Chart Documentation (MANDATORY)

> [!IMPORTANT]
> **When adding, modifying, or deleting charts, you MUST update the corresponding documentation file.**

### Chart Documentation Files

| Page | Documentation File |
|------|-------------------|
| Analytics | `docs/PAGES/ANALYTICS_CHARTS.md` |
| Fridge | `docs/PAGES/FRIDGE_CHARTS.md` |
| Savings | `docs/PAGES/SAVINGS_CHARTS.md` |
| Test Charts | `docs/PAGES/TEST_CHARTS.md` |

### When to Update Documentation

1. **Adding a new chart**: Add entry to the charts table with Chart ID, Component File, Component Name, Description
2. **Modifying a chart**: Update the description or component name if changed
3. **Deleting a chart**: Remove the entry from the table and update the total count
4. **Moving a chart between pages**: Remove from source doc, add to destination doc

### Required Information Per Chart

```markdown
| # | Chart ID | Component File | Component Name | Description |
|---|----------|----------------|----------------|-------------|
| X | `chartId` | `chart-name.tsx` | `ChartName` | Brief description |
```

### Chart Component Checklist

When creating a new chart:
- [ ] Wrap with `React.memo`
- [ ] Add `displayName` property
- [ ] Add to ChartsGrid render logic
- [ ] Add to bundle API if server-side data needed
- [ ] **Update documentation file**

## Chart Component Performance (CRITICAL)

Every chart component **MUST** follow these performance patterns to prevent sluggish page loads and interactions.

### Required for ALL Chart Components

1. **Wrap with `React.memo`** — Prevents re-renders when parent updates but props unchanged
```typescript
import { memo } from "react"

export const ChartMyChart = memo(function ChartMyChart({ data, isLoading }: Props) {
  // Component implementation
})

ChartMyChart.displayName = "ChartMyChart"
```

2. **Use `LazyChart` for below-fold charts** — Defers rendering until near viewport
```typescript
import { LazyChart } from "@/components/lazy-chart"

// In ChartsGrid:
<LazyChart title="My Chart Title" height={250}>
  <ChartMyChart data={data} />
</LazyChart>
```

3. **Memoize expensive computations** — Use `useMemo` for data transformations
```typescript
const processedData = useMemo(() =>
  expensiveTransform(rawData),
  [rawData]
)
```

### Key Performance Files
| File | Purpose |
|------|---------|
| `components/lazy-chart.tsx` | IntersectionObserver wrapper for deferred chart rendering |
| `components/chart-visibility-provider.tsx` | Centralized context for chart category visibility (replaces per-chart localStorage reads) |

### Chart Grids by Page
| Page | Grid File | Has LazyChart |
|------|-----------|---------------|
| Analytics | `app/analytics/_page/components/ChartsGrid.tsx` | ✅ Yes |
| Home | `app/home/_page/components/ChartsGrid.tsx` | ❌ Needs adding |
| Fridge | `app/fridge/_client/components/ChartsGrid.tsx` | ❌ Needs adding |

### Performance Anti-Patterns — AVOID

| ❌ Don't | ✅ Do Instead |
|----------|---------------|
| Export chart without `memo()` | Always wrap exports with `memo()` |
| Render heavy charts immediately | Wrap below-fold charts with `LazyChart` |
| Transition `grid-row`/`grid-column` CSS | Only transition GPU-composited properties (`transform`, `opacity`) |
| Multiple `localStorage.getItem()` per chart | Use `ChartVisibilityProvider` context |
| Inline data transforms in JSX | Use `useMemo` with proper dependencies |

## Security Checklist

Before any change, verify:

- [ ] All queries filter by `user_id = $1`
- [ ] User input validated before DB operations
- [ ] API routes call `getCurrentUserId()` or explicitly handle public access
- [ ] No sensitive data in client code or logs
- [ ] Stripe webhooks verify signature
- [ ] File uploads validate type + size

## Verification

### Build Test (Required)
```bash
npm run build  # Must pass with no errors
```

### Security Review
- [ ] No SQL injection (parameterized queries only)
- [ ] No XSS (sanitize user input in UI)
- [ ] No auth bypass (data endpoints protected)
- [ ] No data leaks (user A can't see user B's data)
- [ ] Rate limiting on public endpoints (Upstash)

### Scalability Review
- [ ] Queries efficient at 100K rows (use EXPLAIN if unsure)
- [ ] No N+1 query problems
- [ ] Caching considered for expensive operations
- [ ] No unnecessary re-renders

## Anti-Patterns — AVOID

| ❌ Don't | ✅ Do Instead |
|----------|---------------|
| Use `any` type | Create proper types in `lib/types/` |
| Create custom UI from scratch | Use existing shadcn components |
| Hard-code secrets | Use environment variables |
| Skip `user_id` filter | Always scope queries by user |
| Write queries without parameterization | Use `$1, $2` placeholders |
| Large, unfocused diffs | Keep changes small and targeted |
| Ignore build failures | Fix all errors before completing |
| Over-engineer | Keep solutions simple; only do what's asked |
| Fetch chart data individually | Add to bundle API + use Redis cache |
| Skip cache invalidation after mutations | Call `invalidateUserCachePrefix()` |

## Deployment

| Environment | Domain | Purpose |
|-------------|--------|---------|
| Staging | `dev.trakzi.com` | All changes deploy here first |
| Production | `trakzi.com` | Only after staging validation |

## Testing

```bash
npm test                              # All tests
npm test -- --watch                   # Watch mode
npm test -- path/to/file.test.ts      # Single file
```

**Guidelines:**
- New features → happy-path + edge-case tests
- Bug fixes → regression test
- Tests mirror source: `__tests__/lib/parsing/parseCsvToRows.test.ts`

## Data Flow

```
CSV/PDF Upload → lib/parsing/ → lib/ai/ (categorization) → Neon DB → lib/charts/ → UI
```

```
Receipt Image → lib/receipts/ocr/ → lib/receipts/parsers/ → Categorization → Neon DB
```

## When Unsure

1. Check `docs/CORE/` for architecture decisions
2. Search existing patterns: `grep -r "pattern" lib/`
3. Ask for clarification rather than assume

## General Behaviour

- Assume **TypeScript + Next.js App Router** best practices.
- Prefer **small, focused diffs**:
  - Do not rewrite whole files unless explicitly requested.
  - If a refactor is needed, outline the plan briefly first (in chat or comments).
- Respect the existing conventions:
  - Use the current ESLint + TS config.
  - Follow patterns already used in `app/`, `lib/`, `components/`, `__tests__/`.
- Do **not** introduce new frameworks or heavy deps without clearly:
  - Explaining why they're necessary.
  - Offering a lighter alternative using existing stack.

When proposing changes:
- Briefly explain **what** and **why**.
- Show complete, copy-pasteable code blocks.
- Keep text explanations short unless the user asks for detail.

## Preferred Project Context

When reading context, prioritise these paths:

1. `app/`          – Next.js routes, pages, route handlers.
2. `lib/`          – shared utilities (Neon client, parsing, AI helpers, types).
3. `components/`   – reusable UI.
4. `hooks/`        – React hooks.
5. `__tests__/`    – Jest tests for logic/components.
6. `docs/`         – documentation and diagrams (see diagram rules below).

Avoid reading large or irrelevant files (build output, lockfiles, static assets) unless strictly needed.

## Error Finding & Code Quality

Whenever you write or modify code:

1. **Think about failure modes**
   - Handle null/undefined, empty data, invalid input, missing env vars, network/API failures.
   - Prefer explicit error handling (`try/catch`, early returns) over silent failures.
   - Log or surface useful error messages; avoid swallowing errors.

2. **Type Safety**
   - Avoid `any` and `unknown` unless truly necessary; create proper types/interfaces.
   - Centralise shared types in `lib/types` (or similar) rather than duplicating.
   - Use exhaustive checks with unions and `switch` where helpful.

3. **Static Checks**
   - Assume the user will run:
     - `npm run lint`
     - `npm test`
   - Write code that should pass TypeScript and ESLint as-is.
   - Fix unused vars, unreachable code, and obvious style issues.

4. **Security & Access Control**
   - Never hard-code secrets or API keys.
   - For anything involving Neon, auth or file uploads, think about:
     - Input validation (dates, numbers, enums).
     - SQL injection and unsafe string concatenation.
     - Per-user access to data (respect `user_id` / privacy constraints).

## Testing Rules (IMPORTANT)

Folio is expected to have **Jest** tests. Whenever you add or modify non-trivial logic:

1. **Location**
   - Place tests in `__tests__/` mirroring the source path, or follow existing test placement.
   - Example: `lib/parsing/parsePdfToRows.ts` → `__tests__/lib/parsing/parsePdfToRows.test.ts`.

2. **When to add tests**
   - New feature → add at least:
     - 1 happy-path test.
     - 1 edge-case/error test.
   - Bugfix → add a regression test that fails before the fix and passes after.
   - Refactor → keep existing tests passing; if behaviour changes intentionally, update tests and mention it.

3. **How**
   - For pure functions (parsers, transformers, AI result handlers):
     - Test input → output clearly, including weird/empty inputs.
   - For components:
     - Use the existing React testing setup (React Testing Library if present).
     - Test visible behaviour / user interaction, not implementation details.

## Backend & Neon

The backend is a **Next.js API layer** that talks to **Neon Postgres via REST/Data API**.

When touching backend code:

- Use neon mcp to understand the layout of the tables, names of the tables and list of items in them.
- Use or extend shared helpers (e.g. `lib/neonClient.ts`) instead of raw `fetch` scattered everywhere.
- Keep all Neon access typed and centralised where possible.
- Validate input before sending to the DB:
  - Check dates, numbers, required fields.
  - Enforce per-user filters (`user_id = current user`) to preserve privacy.
- Never add mock data, unless told to.
- Handle Neon errors:
  - If Neon returns non-200, capture the response text, log internally, and return a friendly error to the client.

## Frontend, UI & **shadcn MCP**

**Very important:**  
Whenever the user asks for **UI elements, components, layouts or redesigns**, follow these rules:

1. **Use shadcn + Tailwind**
   - Prefer **shadcn/ui** components (Buttons, Cards, Dialogs, Tables, Forms, etc.).
   - Style with Tailwind utility classes consistent with existing code.

2. **Use shadcn MCP**
   - When working inside Cursor and generating UI:
     - Use the **shadcn MCP** integration to:
       - Scaffold new shadcn components.
       - Insert or update component code.
       - Ensure imports and paths are correct.
   - Do not reinvent basic UI patterns (buttons, modals, tables) manually if shadcn already provides them.

3. **Consistency**
   - Match the existing design language:
     - Typographic scale.
     - Spacing, border radius, shadows.
   - Avoid introducing competing design systems or CSS frameworks.

4. **Behaviour**
   - Prefer accessible components:
     - Proper roles, labels, keyboard navigation.
   - For dialogs, menus, etc., use shadcn's patterns rather than ad-hoc implementations.

## Project Diagram / Organigram Maintenance

The repo should always have an up-to-date **architecture diagram** representing the main structure and data flow.

**Diagram file:**

- Keep a diagram at: `docs/architecture.mmd` using **Mermaid** syntax.
- Optionally also reference it in `docs/architecture.md`.

**Rules:**

1. On any **significant structural change**:
   - New directories for major features.
   - New backend modules or Neon tables.
   - New external integrations (APIs, services).
   → Update `docs/architecture.mmd` to reflect:
     - Main frontend areas (pages/routes).
     - Backend modules / API endpoints.
     - Neon tables and key relations.
     - Data flow: upload → parsing → AI → DB → graphs.

2. When the user requests:
   - "organigram", "diagram", "architecture diagram", or something similar:
     - Open / read `docs/architecture.mmd`.
     - Update it to match the current project shape.
     - Explain briefly what changed in the diagram.

3. If `docs/architecture.mmd` does not exist:
   - Create it with:
     - A high-level system diagram (e.g., a Mermaid `flowchart` or `graph TD`).
     - A short legend / description.

4. Keep the diagram **high-level and readable**:
   - Do not show every function; focus on modules, services, and tables.
   - Keep node labels concise.

## Performance & Efficiency

- Minimise unnecessary re-renders:
  - Avoid heavy computations in render; extract into hooks or helpers.
  - Use `useMemo`/`useCallback` only when they clearly help, not by default.
- Avoid heavy dependencies unless truly needed:
  - If a library is large, propose a lightweight alternative.
- For async operations (parse, AI, Neon calls):
  - Use `async/await`.
  - Show loading states in the UI where appropriate.
  - Handle timeouts and errors gracefully.

## How To Respond To Prompts (Workflow)

When the user asks for something non-trivial:

1. **Restate concisely** what they want (1–2 sentences).
2. **If its the second or third time asking the same thing then find the edge case and ask yourself why your changes didn't work, find the actual error and fix it**
3. **Identify impacted areas** (e.g., `app/api/...`, `lib/parsing/...`, `components/...`, `docs/architecture.mmd`).
4. **Plan in 2–5 bullets** if the change is larger than a small bugfix.
5. Implement in this order:
   - (If applicable) add or adjust tests.
   - Implement code changes.
   - Update `docs/architecture.mmd` if the project structure changed.
6. At the end, summarise:
   - Files changed.
   - Tests added/updated.
   - Any follow-up steps

## Things To Avoid

- Do **not**:
  - Use `any` as a default solution to type errors.
  - Remove tests without a clear reason.
  - Change the global architecture (e.g., REST → GraphQL) unless explicitly asked.
  - Introduce a new UI library instead of shadcn/ui without clear user approval.

- If you are unsure about a requirement:
  - State your assumption explicitly.
  - Choose a safe, simple implementation and mark TODOs where needed.

---
alwaysApply: true
---
