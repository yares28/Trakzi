# Hybrid Import Pipeline v2 — Implementation Plan

**Objective**: Upgrade the transaction import pipeline to improve categorization accuracy and UX by introducing a two-stage enrichment process: simplify description (rules-first, AI fallback) → categorize using simplified description (AI).

**Created**: 2025-12-31  
**Status**: Planning Phase  
**Target Version**: v2_hybrid

---

## Table of Contents

1. [Overview](#overview)
2. [Database Changes](#database-changes)
3. [Current Architecture Analysis](#current-architecture-analysis)
4. [Implementation Roadmap](#implementation-roadmap)
5. [Detailed Implementation Steps](#detailed-implementation-steps)
6. [Testing Plan](#testing-plan)
7. [Rollout Strategy](#rollout-strategy)

---

## Overview

### Hard Constraints

- ✅ **ONLY ONE DB COLUMN**: Add `simplified_description` to `transactions` table
- ✅ **NO OTHER COLUMNS**: All metadata goes into existing JSON field
- ✅ **PRESERVE RAW**: Keep existing `description` column unchanged (raw bank description)
- ✅ **SECURITY**: Never send sensitive info to AI (sanitize first)
- ✅ **AUDIT TRAIL**: Store simplification + categorization metadata for debugging

### Pipeline Flow

```
Current Flow:
Upload → Parse → Normalize → AI Categorize → DB Insert

New v2 Flow:
Upload → Parse → Normalize → Sanitize → Rule-based Simplify → AI Simplify (fallback) 
  → persist simplified_description → AI Categorize (from simplified) → DB Insert
```

---

## Database Changes

### Migration 1: Add `simplified_description` Column

**File**: `prisma/migrations/YYYYMMDD_add_simplified_description/migration.sql`

```sql
-- Add simplified_description column to transactions table
ALTER TABLE transactions 
ADD COLUMN IF NOT EXISTS simplified_description VARCHAR(255);

-- Optional: Add index for merchant search/filter
CREATE INDEX IF NOT EXISTS idx_transactions_simplified_description 
ON transactions(simplified_description);

-- Add comment for documentation
COMMENT ON COLUMN transactions.simplified_description IS 
'Simplified merchant/label (e.g., "Amazon", "Transfer Juan", "Bank Fee"). Generated by hybrid pipeline v2.';
```

### Update Prisma Schema

**File**: `prisma/schema.prisma`

```prisma
model Transaction {
  id                    Int       @id @default(autoincrement())
  userId                String    @map("user_id")
  statementId           Int?      @map("statement_id")
  txDate                DateTime  @map("tx_date") @db.Date
  txTime                DateTime? @map("tx_time") @db.Time()
  description           String    // Raw bank description (unchanged)
  simplifiedDescription String?   @map("simplified_description") // NEW: Simplified merchant/label
  amount                Decimal   @db.Decimal(12, 2)
  balance               Decimal?  @db.Decimal(12, 2)
  categoryId            Int?      @map("category_id")
  currency              String    @default("EUR")
  rawCsvRow             Json?     @map("raw_csv_row") // Will contain v2 metadata
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")

  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], name: "idx_transactions_user")
  @@index([userId, txDate(sort: Desc)], name: "idx_transactions_user_date")
  @@index([simplifiedDescription], name: "idx_transactions_simplified_description") // NEW
  @@map("transactions")
}
```

### Metadata Schema (stored in `raw_csv_row` JSON field)

```typescript
interface TransactionMetadata {
  pipeline_version: "v2_hybrid";
  sanitized_description: string;
  simplify: {
    source: "rules" | "ai";
    confidence: number; // 0.0 - 1.0
    matched_rule?: string; // e.g., "merchant:mercadona", "transfer:bizum", "fee"
    type_hint?: "merchant" | "transfer" | "fee" | "atm" | "salary" | "refund" | "other";
  };
  categorize: {
    source: "ai" | "manual" | "preference";
    confidence: number;
    model?: string; // AI model used
  };
  errors?: string[]; // Any errors encountered during processing
  // Original CSV row data (preserving existing behavior)
  date?: string;
  time?: string;
  description?: string;
  amount?: number;
  balance?: number;
  category?: string;
}
```

---

## Current Architecture Analysis

### Key Files & Their Roles

#### 1. **Import Pipeline Entry Points**

| File | Role | Modification Needed |
|------|------|---------------------|
| `app/api/statements/parse/route.ts` | Parses CSV/PDF/XLSX files → canonical CSV | Add sanitization + simplification before categorization |
| `app/api/statements/import/route.ts` | Imports parsed CSV → DB | Add `simplified_description` to insert |
| `components/file-upload-csv.tsx` | UI for CSV upload | No changes needed |
| `components/csv-review-dialog.tsx` | Review dialog before import | Add preview of simplified descriptions |

#### 2. **AI Categorization**

| File | Current Function | Modification Needed |
|------|------------------|---------------------|
| `lib/ai/categoriseTransactions.ts` | AI categorization of transactions | **MAJOR CHANGES**: Split into simplify + categorize, add rule-based simplification |

**Current categorization logic** (lines 1-1404):
- Has merchant patterns (`MERCHANT_PATTERNS`)
- Has category rules (`CATEGORY_RULES`)
- Has category keywords (`CATEGORY_KEYWORDS`)
- Uses OpenRouter API for categorization

**Reuse opportunities**:
- ✅ `MERCHANT_PATTERNS` → basis for rule-based simplification
- ✅ Existing categorization prompt structure
- ✅ Batching logic
- ❌ Current approach does NOT simplify first, categorizes from raw description

#### 3. **Transaction Types**

| File | Current Structure | Changes Needed |
|------|-------------------|----------------|
| `lib/types/transactions.ts` | Defines `TxRow` type | Add `simplifiedDescription?: string` |

Current `TxRow`:
```typescript
export type TxRow = {
    date: string;
    time?: string | null;
    description: string;
    amount: number;
    balance: number | null;
    category?: string;
    summary?: string; // Already exists! Can repurpose or rename
};
```

**Note**: `summary` field already exists! We can either:
- Option A: Rename `summary` → `simplifiedDescription` globally
- Option B: Use both (`summary` for display, `simplifiedDescription` for DB)
- **Recommendation**: Use `simplifiedDescription` consistently, deprecate `summary`

#### 4. **Database Client**

| File | Role |
|------|------|
| `lib/neonClient.ts` | Raw SQL interface to Neon Postgres |

---

## Implementation Roadmap

### Phase 1: Foundation (Days 1-2)
- [ ] Database migration
- [ ] Update TypeScript types
- [ ] Create sanitization utility
- [ ] Create rule-based simplification utility

### Phase 2: Core Logic (Days 3-5)
- [ ] Implement transfer name extraction
- [ ] Implement AI simplify (fallback)
- [ ] Implement AI categorize (from simplified)
- [ ] Add metadata persistence

### Phase 3: Integration (Days 6-7)
- [ ] Integrate into parse route
- [ ] Integrate into import route
- [ ] Update UI review dialog
- [ ] Add batching and caching

### Phase 4: Testing & Refinement (Days 8-10)
- [ ] Unit tests for all utilities
- [ ] Integration tests
- [ ] Manual testing with real data
- [ ] Performance optimization

### Phase 5: Deployment (Day 11)
- [ ] Feature flag setup
- [ ] Gradual rollout
- [ ] Monitoring and alerting

---

## Detailed Implementation Steps

### Step 1: Database Migration

**File**: Create `prisma/migrations/20250101_add_simplified_description/migration.sql`

```sql
-- Add simplified_description column
ALTER TABLE transactions 
ADD COLUMN IF NOT EXISTS simplified_description VARCHAR(255);

-- Add index for merchant filtering
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_transactions_simplified_description 
ON transactions(simplified_description);

-- Add comment
COMMENT ON COLUMN transactions.simplified_description IS 
'Simplified merchant/label generated by hybrid pipeline v2';
```

**Run migration**:
```bash
npx prisma db push
npx prisma generate
```

---

### Step 2: Update TypeScript Types

**File**: `lib/types/transactions.ts`

```typescript
// lib/types/transactions.ts
export type TxRow = {
    date: string;                    // ISO: YYYY-MM-DD
    time?: string | null;            // Optional time (HH:MM[:SS])
    description: string;             // Raw bank description
    simplifiedDescription?: string;  // NEW: Simplified merchant/label
    amount: number;
    balance: number | null;
    category?: string;
    
    // Deprecated: use simplifiedDescription instead
    // @deprecated
    summary?: string;
};

export type SimplifyResult = {
    simplified: string | null;
    confidence: number;              // 0.0 - 1.0
    matchedRule?: string;            // e.g., "merchant:mercadona"
    typeHint?: "merchant" | "transfer" | "fee" | "atm" | "salary" | "refund" | "other";
};

export type CategorizeResult = {
    category: string;
    confidence: number;
};

export type TransactionMetadata = {
    pipeline_version: "v2_hybrid";
    sanitized_description: string;
    simplify: {
        source: "rules" | "ai";
        confidence: number;
        matched_rule?: string;
        type_hint?: string;
    };
    categorize: {
        source: "ai" | "manual" | "preference";
        confidence: number;
        model?: string;
    };
    errors?: string[];
};
```

---

### Step 3: Create Sanitization Utility

**File**: Create `lib/ai/sanitize-description.ts`

```typescript
// lib/ai/sanitize-description.ts

/**
 * Sanitizes transaction description by removing sensitive information
 * before sending to AI or processing.
 * 
 * Masks:
 * - Card numbers (e.g., *1234, CARD 1234)
 * - IBAN-like sequences
 * - Phone numbers
 * - Authorization codes
 * - Long numeric references
 */
export function sanitizeDescription(raw: string): string {
    if (!raw) return "";
    
    let sanitized = raw;
    
    // 1. Mask card numbers and PAN sequences
    // Patterns: "TARJ*1234", "CARD 1234", "**** 1234", etc.
    sanitized = sanitized.replace(/\b(TARJ|CARD|CARTE)\s*\*?\d{4}\b/gi, "CARD");
    sanitized = sanitized.replace(/\*{4}\s*\d{4}\b/g, "CARD");
    sanitized = sanitized.replace(/\d{4}\s*\*{4}/g, "CARD");
    
    // 2. Mask IBAN-like sequences (2 letters + 20+ digits/letters)
    sanitized = sanitized.replace(/\b[A-Z]{2}\d{2}[A-Z0-9]{16,}\b/gi, "IBAN");
    
    // 3. Mask phone numbers
    // Patterns: +34 123 456 789, 123-456-7890, etc.
    sanitized = sanitized.replace(/\+?\d{1,3}[\s.-]?\(?\d{2,4}\)?[\s.-]?\d{3,4}[\s.-]?\d{3,4}/g, "PHONE");
    
    // 4. Mask authorization codes (AUTH, AUTORIZACION, etc. followed by alphanumeric)
    sanitized = sanitized.replace(/\b(AUTH|AUTORIZACION|AUTHORIZATION|AUT|REF)\s*[:.]?\s*[A-Z0-9]{6,}\b/gi, "AUTH");
    
    // 5. Mask long numeric sequences (likely transaction IDs, references)
    sanitized = sanitized.replace(/\b\d{10,}\b/g, "REF");
    
    // 6. Clean up multiple spaces
    sanitized = sanitized.replace(/\s+/g, " ").trim();
    
    return sanitized;
}

/**
 * Extracts merchant keywords and meaningful tokens after sanitization
 */
export function extractMerchantTokens(sanitized: string): string[] {
    if (!sanitized) return [];
    
    // Convert to uppercase for pattern matching
    const upper = sanitized.toUpperCase();
    
    // Split by common separators
    const tokens = upper.split(/[\s\-_\/\\,;:|]+/).filter(Boolean);
    
    // Filter out noise tokens
    const noise = new Set([
        "COMPRA", "PAGO", "PAYMENT", "PURCHASE", "ACHAT",
        "EN", "IN", "AT", "DE", "DEL", "LA", "EL",
        "WWW", "HTTP", "HTTPS",
        "CARD", "IBAN", "PHONE", "AUTH", "REF", // Our sanitization placeholders
    ]);
    
    return tokens.filter(token => !noise.has(token) && token.length >= 3);
}
```

**Test File**: Create `__tests__/lib/sanitize-description.test.ts`

```typescript
import { sanitizeDescription, extractMerchantTokens } from "@/lib/ai/sanitize-description";

describe("sanitizeDescription", () => {
    test("masks card numbers", () => {
        expect(sanitizeDescription("COMPRA TARJ*1234 AMAZON")).toBe("COMPRA CARD AMAZON");
        expect(sanitizeDescription("PAYMENT CARD 5678 ZARA")).toBe("PAYMENT CARD ZARA");
        expect(sanitizeDescription("**** 9012 MERCADONA")).toBe("CARD MERCADONA");
    });
    
    test("masks IBAN sequences", () => {
        expect(sanitizeDescription("TRF ES9121000418450200051332 JOHN"))
            .toBe("TRF IBAN JOHN");
    });
    
    test("masks phone numbers", () => {
        expect(sanitizeDescription("CALL +34 123 456 789 SUPPORT"))
            .toBe("CALL PHONE SUPPORT");
        expect(sanitizeDescription("SMS 123-456-7890 VERIFY"))
            .toBe("SMS PHONE VERIFY");
    });
    
    test("masks authorization codes", () => {
        expect(sanitizeDescription("AUTH:ABC123XYZ AMAZON"))
            .toBe("AUTH AMAZON");
        expect(sanitizeDescription("AUTORIZACION CW4WE8Q35 SPOTIFY"))
            .toBe("AUTH SPOTIFY");
    });
    
    test("masks long numeric sequences", () => {
        expect(sanitizeDescription("REF 1234567890123 TRANSFERENCIA"))
            .toBe("REF REF TRANSFERENCIA");
    });
    
    test("preserves meaningful merchant names", () => {
        expect(sanitizeDescription("COMPRA ONLINE AMAZON.ES"))
            .toContain("AMAZON");
        expect(sanitizeDescription("PAGO MERCADONA VALENCIA"))
            .toContain("MERCADONA");
    });
});

describe("extractMerchantTokens", () => {
    test("extracts merchant tokens", () => {
        const tokens = extractMerchantTokens("COMPRA AMAZON LIBROS");
        expect(tokens).toContain("AMAZON");
        expect(tokens).toContain("LIBROS");
        expect(tokens).not.toContain("COMPRA"); // noise word
    });
});
```

---

### Step 4: Create Rule-Based Simplification

**File**: Create `lib/ai/rule-simplify.ts`

```typescript
// lib/ai/rule-simplify.ts
import { SimplifyResult } from "@/lib/types/transactions";
import { sanitizeDescription, extractMerchantTokens } from "./sanitize-description";

type MerchantRule = {
    pattern: RegExp;
    simplified: string;
    typeHint: SimplifyResult["typeHint"];
    confidence: number;
};

type OperationRule = {
    patterns: RegExp[];
    simplified: string;
    typeHint: SimplifyResult["typeHint"];
    confidence: number;
};

// Spain-heavy merchant dictionary
const MERCHANT_RULES: MerchantRule[] = [
    // Groceries
    { pattern: /mercadona/i, simplified: "Mercadona", typeHint: "merchant", confidence: 0.95 },
    { pattern: /carrefour/i, simplified: "Carrefour", typeHint: "merchant", confidence: 0.95 },
    { pattern: /lidl/i, simplified: "Lidl", typeHint: "merchant", confidence: 0.95 },
    { pattern: /\bdia\b/i, simplified: "DIA", typeHint: "merchant", confidence: 0.95 },
    { pattern: /aldi/i, simplified: "Aldi", typeHint: "merchant", confidence: 0.95 },
    { pattern: /eroski/i, simplified: "Eroski", typeHint: "merchant", confidence: 0.95 },
    
    // Online retail
    { pattern: /amazon/i, simplified: "Amazon", typeHint: "merchant", confidence: 0.95 },
    { pattern: /aliexpress/i, simplified: "AliExpress", typeHint: "merchant", confidence: 0.95 },
    { pattern: /shein/i, simplified: "Shein", typeHint: "merchant", confidence: 0.95 },
    
    // Food delivery
    { pattern: /glovo/i, simplified: "Glovo", typeHint: "merchant", confidence: 0.95 },
    { pattern: /just\s*eat/i, simplified: "Just Eat", typeHint: "merchant", confidence: 0.95 },
    { pattern: /uber\s*eats/i, simplified: "Uber Eats", typeHint: "merchant", confidence: 0.9 },
    
    // Transport
    { pattern: /uber(?!\s*eats)/i, simplified: "Uber", typeHint: "merchant", confidence: 0.9 },
    { pattern: /cabify/i, simplified: "Cabify", typeHint: "merchant", confidence: 0.9 },
    { pattern: /bolt/i, simplified: "Bolt", typeHint: "merchant", confidence: 0.85 },
    { pattern: /ryanair/i, simplified: "Ryanair", typeHint: "merchant", confidence: 0.9 },
    { pattern: /iberia/i, simplified: "Iberia", typeHint: "merchant", confidence: 0.9 },
    { pattern: /renfe/i, simplified: "Renfe", typeHint: "merchant", confidence: 0.9 },
    
    // Subscriptions
    { pattern: /spotify/i, simplified: "Spotify", typeHint: "merchant", confidence: 0.95 },
    { pattern: /netflix/i, simplified: "Netflix", typeHint: "merchant", confidence: 0.95 },
    { pattern: /apple/i, simplified: "Apple", typeHint: "merchant", confidence: 0.85 },
    { pattern: /google/i, simplified: "Google", typeHint: "merchant", confidence: 0.85 },
    
    // Payment services
    { pattern: /paypal/i, simplified: "PayPal", typeHint: "merchant", confidence: 0.9 },
    { pattern: /stripe/i, simplified: "Stripe", typeHint: "merchant", confidence: 0.9 },
    { pattern: /revolut/i, simplified: "Revolut", typeHint: "merchant", confidence: 0.9 },
    { pattern: /wise/i, simplified: "Wise", typeHint: "merchant", confidence: 0.9 },
    
    // Fashion
    { pattern: /zara/i, simplified: "Zara", typeHint: "merchant", confidence: 0.95 },
    { pattern: /inditex/i, simplified: "Inditex", typeHint: "merchant", confidence: 0.9 },
    { pattern: /\bh&m\b|h\s*&\s*m/i, simplified: "H&M", typeHint: "merchant", confidence: 0.9 },
    
    // Department stores
    { pattern: /el\s*corte\s*ingles/i, simplified: "El Corte Inglés", typeHint: "merchant", confidence: 0.95 },
];

const OPERATION_RULES: OperationRule[] = [
    {
        patterns: [/comision|fee|gastos|charge/i],
        simplified: "Bank Fee",
        typeHint: "fee",
        confidence: 0.8,
    },
    {
        patterns: [/cajero|atm|retirada|withdrawal/i],
        simplified: "ATM Withdrawal",
        typeHint: "atm",
        confidence: 0.85,
    },
    {
        patterns: [/nomina|salario|payroll/i],
        simplified: "Salary",
        typeHint: "salary",
        confidence: 0.85,
    },
    {
        patterns: [/devolucion|refund|reverso|reversal/i],
        simplified: "Refund",
        typeHint: "refund",
        confidence: 0.85,
    },
];

/**
 * Attempts to simplify a transaction description using rule-based matching.
 * Returns null if no confident match found (AI fallback needed).
 */
export function ruleSimplifyDescription(sanitized: string): SimplifyResult {
    if (!sanitized) {
        return { simplified: null, confidence: 0 };
    }
    
    const upperSanitized = sanitized.toUpperCase();
    
    // 1. Check merchant rules (highest priority)
    for (const rule of MERCHANT_RULES) {
        if (rule.pattern.test(sanitized)) {
            return {
                simplified: rule.simplified,
                confidence: rule.confidence,
                matchedRule: `merchant:${rule.simplified.toLowerCase()}`,
                typeHint: rule.typeHint,
            };
        }
    }
    
    // 2. Check for transfer/Bizum patterns (special handling)
    const transferResult = detectTransfer(sanitized);
    if (transferResult) {
        return transferResult;
    }
    
    // 3. Check operation rules (fees, ATM, salary, refund)
    for (const rule of OPERATION_RULES) {
        for (const pattern of rule.patterns) {
            if (pattern.test(sanitized)) {
                return {
                    simplified: rule.simplified,
                    confidence: rule.confidence,
                    matchedRule: rule.typeHint || "operation",
                    typeHint: rule.typeHint,
                };
            }
        }
    }
    
    // No confident rule match → AI fallback needed
    return { simplified: null, confidence: 0 };
}

/**
 * Detects transfer/Bizum transactions and extracts first name if present.
 */
function detectTransfer(sanitized: string): SimplifyResult | null {
    const transferPatterns = [
        /bizum/i,
        /transferencia/i,
        /\btrf\b/i,
        /sepa/i,
        /\bp2p\b/i,
        /giro/i,
    ];
    
    let isTransfer = false;
    let isBizum = false;
    
    for (const pattern of transferPatterns) {
        if (pattern.test(sanitized)) {
            isTransfer = true;
            if (/bizum/i.test(sanitized)) {
                isBizum = true;
            }
            break;
        }
    }
    
    if (!isTransfer) return null;
    
    // Extract name if present
    const firstName = extractFirstName(sanitized);
    
    if (firstName) {
        const label = isBizum ? "Bizum" : "Transfer";
        return {
            simplified: `${label} ${firstName}`,
            confidence: 0.85,
            matchedRule: isBizum ? "transfer:bizum" : "transfer",
            typeHint: "transfer",
        };
    }
    
    // Transfer detected but no name
    return {
        simplified: isBizum ? "Bizum" : "Transfer",
        confidence: 0.8,
        matchedRule: isBizum ? "transfer:bizum" : "transfer",
        typeHint: "transfer",
    };
}

// Honorifics to ignore (multilingual)
const HONORIFICS = new Set([
    "MR", "MRS", "MS", "MISS", "SIR", "MADAM",
    "MONSIEUR", "MME", "MLLE",
    "SR", "SRA", "SRTA", "DON", "DOÑA", "D",
    "DR", "DRA", "PROF", "ING", "LIC",
]);

/**
 * Extracts first name from transfer description.
 * Rules:
 * - Look for patterns like "BIZUM A <name>", "TRANSFERENCIA <name>"
 * - Keep only first name token
 * - Ignore honorifics
 * - Apply title case
 */
function extractFirstName(text: string): string | null {
    if (!text) return null;
    
    // Patterns to find name context
    const namePatterns = [
        /bizum\s+(?:a\s+|de\s+)?(.+)/i,
        /transferencia\s+(?:a\s+)?(.+)/i,
        /sepa\s+(.+)/i,
        /\bp2p\s+(.+)/i,
    ];
    
    let nameCandidate = "";
    
    for (const pattern of namePatterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
            nameCandidate = match[1].trim();
            break;
        }
    }
    
    if (!nameCandidate) return null;
    
    // Tokenize by whitespace and punctuation
    const tokens = nameCandidate
        .split(/[\s,;:.]+/)
        .map(t => t.trim())
        .filter(t => t.length > 0);
    
    // Find first non-honorific token
    for (const token of tokens) {
        const upper = token.toUpperCase();
        const normalized = upper.replace(/\./g, ""); // Remove periods
        
        if (!HONORIFICS.has(normalized) && /^[A-Z]+$/i.test(token)) {
            // Apply title case
            return toTitleCase(token);
        }
    }
    
    return null;
}

function toTitleCase(str: string): string {
    if (!str) return "";
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}
```

**Test File**: Create `__tests__/lib/rule-simplify.test.ts`

```typescript
import { ruleSimplifyDescription } from "@/lib/ai/rule-simplify";
import { sanitizeDescription } from "@/lib/ai/sanitize-description";

describe("ruleSimplifyDescription", () => {
    test("simplifies known merchants", () => {
        const result = ruleSimplifyDescription(sanitizeDescription("COMPRA MERCADONA VALENCIA"));
        expect(result.simplified).toBe("Mercadona");
        expect(result.confidence).toBeGreaterThanOrEqual(0.9);
        expect(result.typeHint).toBe("merchant");
    });
    
    test("simplifies Amazon transactions", () => {
        const result = ruleSimplifyDescription(sanitizeDescription("PAGO WWW.AMAZON.ES CARD"));
        expect(result.simplified).toBe("Amazon");
        expect(result.confidence).toBeGreaterThanOrEqual(0.9);
    });
    
    test("detects bank fees", () => {
        const result = ruleSimplifyDescription("COMISION MANTENIMIENTO CUENTA");
        expect(result.simplified).toBe("Bank Fee");
        expect(result.typeHint).toBe("fee");
    });
    
    test("detects ATM withdrawals", () => {
        const result = ruleSimplifyDescription("RETIRADA CAJERO AUTOMATICO");
        expect(result.simplified).toBe("ATM Withdrawal");
        expect(result.typeHint).toBe("atm");
    });
    
    test("detects salary", () => {
        const result = ruleSimplifyDescription("NOMINA MES DICIEMBRE");
        expect(result.simplified).toBe("Salary");
        expect(result.typeHint).toBe("salary");
    });
    
    test("extracts name from Bizum transfer", () => {
        const result = ruleSimplifyDescription("BIZUM A SR JUAN PEREZ");
        expect(result.simplified).toBe("Bizum Juan");
        expect(result.typeHint).toBe("transfer");
    });
    
    test("extracts name from transfer (ignores MRS honorific)", () => {
        const result = ruleSimplifyDescription("TRANSFERENCIA MRS ANNA SMITH");
        expect(result.simplified).toBe("Transfer Anna");
    });
    
    test("handles transfer without name", () => {
        const result = ruleSimplifyDescription("TRANSFERENCIA SEPA");
        expect(result.simplified).toBe("Transfer");
        expect(result.typeHint).toBe("transfer");
    });
    
    test("returns null for unknown descriptions", () => {
        const result = ruleSimplifyDescription("COMPRA LOCAL DESCONOCIDO 123");
        expect(result.simplified).toBeNull();
        expect(result.confidence).toBe(0);
    });
});
```

---

### Step 5: Implement AI Simplify (Fallback)

**File**: Create `lib/ai/ai-simplify.ts`

```typescript
// lib/ai/ai-simplify.ts
import { SimplifyResult } from "@/lib/types/transactions";
import { getSiteUrl, getSiteName } from "@/lib/env";

const AI_SIMPLIFY_MODEL = process.env.OPENROUTER_SIMPLIFY_MODEL || "anthropic/claude-3.5-sonnet";
const SIMPLIFY_BATCH_SIZE = 100;

type SimplifyBatchItem = {
    id: string;
    sanitized_description: string;
};

type SimplifyBatchResult = {
    id: string;
    simplified_description: string;
    confidence: number;
};

/**
 * AI-based simplification (fallback when rules don't match).
 * Batches transactions for efficiency.
 */
export async function aiSimplifyBatch(items: SimplifyBatchItem[]): Promise<Map<string, SimplifyResult>> {
    if (items.length === 0) return new Map();
    
    const apiKey = process.env.OPENROUTER_API_KEY;
    if (!apiKey) {
        throw new Error("AI simplification requires OPENROUTER_API_KEY");
    }
    
    const systemPrompt = `
Return STRICT JSON only.

You are given sanitized bank transaction descriptions (sensitive numbers removed).
Task: Produce a short simplified_description (1–4 words).
Rules:
- Prefer merchant/brand name when evident (Amazon, Mercadona, Uber, etc.).
- If it is a transfer, output:
  - "Bizum <FirstName>" for Bizum
  - "Transfer <FirstName>" for other transfers
  Keep ONLY the first name. Ignore honorifics like Mr/Mrs/Ms/Sr/Sra/Dr/Don/Doña (they do not count as a word).
- If no merchant is clear, choose a meaningful label: Card Payment, Transfer, Bizum, Bank Fee, ATM Withdrawal, Salary, Refund.
- Do NOT include locations unless needed for disambiguation.
- Do NOT output any additional text besides JSON.

Input JSON:
{
  "items": [
    { "id": "t1", "sanitized_description": "..." }
  ]
}

Output JSON schema:
{
  "results": [
    { "id": "t1", "simplified_description": "Amazon", "confidence": 0.95 }
  ]
}
`.trim();
    
    const results = new Map<string, SimplifyResult>();
    
    // Process in batches
    for (let i = 0; i < items.length; i += SIMPLIFY_BATCH_SIZE) {
        const batch = items.slice(i, i + SIMPLIFY_BATCH_SIZE);
        
        const userPrompt = JSON.stringify({ items: batch }, null, 2);
        
        const res = await fetch("https://openrouter.ai/api/v1/chat/completions", {
            method: "POST",
            headers: {
                "Authorization": `Bearer ${apiKey}`,
                "HTTP-Referer": getSiteUrl(),
                "X-Title": getSiteName(),
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                model: AI_SIMPLIFY_MODEL,
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt },
                ],
                response_format: { type: "json_object" },
                provider: { sort: "throughput" },
            }),
        });
        
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`AI simplify failed (${res.status}): ${errorText.substring(0, 200)}`);
        }
        
        const json = await res.json();
        const content = json.choices?.[0]?.message?.content;
        if (!content) {
            throw new Error("AI simplify response was empty");
        }
        
        let parsed: { results?: SimplifyBatchResult[] };
        try {
            parsed = JSON.parse(content);
        } catch {
            throw new Error("AI simplify response was not valid JSON");
        }
        
        const batchResults = parsed.results || [];
        for (const result of batchResults) {
            results.set(result.id, {
                simplified: result.simplified_description || null,
                confidence: result.confidence || 0.5,
                matchedRule: undefined,
                typeHint: undefined,
            });
        }
    }
    
    return results;
}
```

---

### Step 6: Update AI Categorization (from simplified)

**File**: Modify `lib/ai/categoriseTransactions.ts`

Add new function to categorize from simplified description:

```typescript
// Add to lib/ai/categoriseTransactions.ts

type CategorizeBatchItem = {
    id: string;
    simplified_description: string;
    sanitized_description: string; // Secondary context
};

type CategorizeBatchResult = {
    id: string;
    category: string;
    confidence: number;
};

/**
 * AI categorization using simplified_description as primary signal.
 * sanitized_description is included only for disambiguation.
 */
export async function aiCategorizeBatch(
    items: CategorizeBatchItem[],
    categories: string[]
): Promise<Map<string, CategorizeResult>> {
    if (items.length === 0) return new Map();
    
    const apiKey = process.env.OPENROUTER_API_KEY;
    if (!apiKey) {
        throw new Error("AI categorization requires OPENROUTER_API_KEY");
    }
    
    const categoryList = categories.join(", ");
    
    const systemPrompt = `
Return STRICT JSON only.

Task: Assign a category to each transaction. Use simplified_description primarily.
Use sanitized_description only if needed for disambiguation.

Allowed categories (MUST choose exactly one):
${categoryList}

Input JSON:
{
  "items": [
    {
      "id": "t1",
      "simplified_description": "Mercadona",
      "sanitized_description": "PAGO MOVIL EN MERCADONA ..."
    }
  ]
}

Output JSON schema:
{
  "results": [
    { "id": "t1", "category": "Groceries", "confidence": 0.95 }
  ]
}
`.trim();
    
    const results = new Map<string, CategorizeResult>();
    const BATCH_SIZE = 150;
    
    for (let i = 0; i < items.length; i += BATCH_SIZE) {
        const batch = items.slice(i, i + BATCH_SIZE);
        const userPrompt = JSON.stringify({ items: batch }, null, 2);
        
        const res = await fetch("https://openrouter.ai/api/v1/chat/completions", {
            method: "POST",
            headers: {
                "Authorization": `Bearer ${apiKey}`,
                "HTTP-Referer": getSiteUrl(),
                "X-Title": getSiteName(),
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                model: AI_CATEGORY_MODEL,
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt },
                ],
                response_format: { type: "json_object" },
                provider: { sort: "throughput" },
            }),
        });
        
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`AI categorize failed (${res.status}): ${errorText.substring(0, 200)}`);
        }
        
        const json = await res.json();
        const content = json.choices?.[0]?.message?.content;
        if (!content) {
            throw new Error("AI categorize response was empty");
        }
        
        let parsed: { results?: CategorizeBatchResult[] };
        try {
            parsed = JSON.parse(content);
        } catch {
            throw new Error("AI categorize response was not valid JSON");
        }
        
        const batchResults = parsed.results || [];
        for (const result of batchResults) {
            results.set(result.id, {
                category: result.category || "Other",
                confidence: result.confidence || 0.5,
            });
        }
    }
    
    return results;
}
```

---

### Step 7: Integrate into Parse Route

**File**: Modify `app/api/statements/parse/route.ts`

After parsing transactions, add simplification and categorization:

```typescript
// In app/api/statements/parse/route.ts
// After line ~1050 where categoriseTransactions is called

import { sanitizeDescription } from "@/lib/ai/sanitize-description";
import { ruleSimplifyDescription } from "@/lib/ai/rule-simplify";
import { aiSimplifyBatch } from "@/lib/ai/ai-simplify";
import { aiCategorizeBatch } from "@/lib/ai/categoriseTransactions";

// Replace existing categorization logic with:

// Step 1: Sanitize all descriptions
for (const row of parsedRows) {
    const sanitized = sanitizeDescription(row.description);
    // Store sanitized in metadata (will be persisted later)
    (row as any).__metadata = { sanitized_description: sanitized };
}

// Step 2: Rule-based simplification (first pass)
const needsAiSimplify: Array<{ id: string; sanitized: string; row: TxRow }> = [];

for (let i = 0; i < parsedRows.length; i++) {
    const row = parsedRows[i];
    const sanitized = (row as any).__metadata.sanitized_description;
    const ruleResult = ruleSimplifyDescription(sanitized);
    
    if (ruleResult.simplified && ruleResult.confidence >= 0.75) {
        // Rule matched with high confidence
        row.simplifiedDescription = ruleResult.simplified;
        (row as any).__metadata.simplify = {
            source: "rules",
            confidence: ruleResult.confidence,
            matched_rule: ruleResult.matchedRule,
            type_hint: ruleResult.typeHint,
        };
    } else {
        // Needs AI fallback
        needsAiSimplify.push({
            id: `tx_${i}`,
            sanitized,
            row,
        });
    }
}

// Step 3: AI simplify (fallback for unmatched)
if (needsAiSimplify.length > 0) {
    const aiSimplifyItems = needsAiSimplify.map(item => ({
        id: item.id,
        sanitized_description: item.sanitized,
    }));
    
    const aiSimplifyResults = await aiSimplifyBatch(aiSimplifyItems);
    
    for (const item of needsAiSimplify) {
        const aiResult = aiSimplifyResults.get(item.id);
        if (aiResult?.simplified) {
            item.row.simplifiedDescription = aiResult.simplified;
            (item.row as any).__metadata.simplify = {
                source: "ai",
                confidence: aiResult.confidence,
            };
        } else {
            // Fallback to sanitized description
            item.row.simplifiedDescription = item.sanitized.substring(0, 50);
            (item.row as any).__metadata.simplify = {
                source: "ai",
                confidence: 0.3,
            };
        }
    }
}

// Step 4: AI categorization (using simplified description)
const categorizeItems = parsedRows.map((row, i) => ({
    id: `tx_${i}`,
    simplified_description: row.simplifiedDescription || "",
    sanitized_description: (row as any).__metadata.sanitized_description,
}));

const categoryResults = await aiCategorizeBatch(categorizeItems, DEFAULT_CATEGORIES);

for (let i = 0; i < parsedRows.length; i++) {
    const row = parsedRows[i];
    const catResult = categoryResults.get(`tx_${i}`);
    
    if (catResult) {
        row.category = catResult.category;
        (row as any).__metadata.categorize = {
            source: "ai",
            confidence: catResult.confidence,
            model: AI_CATEGORY_MODEL,
        };
    } else {
        row.category = "Other";
        (row as any).__metadata.categorize = {
            source: "ai",
            confidence: 0,
        };
    }
}

// Step 5: Build final metadata JSON for each row
for (const row of parsedRows) {
    const metadata = (row as any).__metadata;
    (row as any).metadata_json = {
        pipeline_version: "v2_hybrid",
        sanitized_description: metadata.sanitized_description,
        simplify: metadata.simplify,
        categorize: metadata.categorize,
    };
}
```

---

### Step 8: Update Import Route

**File**: Modify `app/api/statements/import/route.ts`

Update DB insert to include `simplified_description`:

```typescript
// In app/api/statements/import/route.ts
// Around line 271-286 where txRows are built

const txRows = rowsToInsert.map((r) => {
    const metadata: TransactionMetadata = (r as any).metadata_json || {
        pipeline_version: "v2_hybrid",
        sanitized_description: r.description,
        simplify: { source: "rules", confidence: 0 },
        categorize: { source: "manual", confidence: 0 },
    };
    
    return {
        user_id: userId,
        statement_id: statementId,
        tx_date: r.date,
        tx_time: r.time ?? null,
        description: r.description, // Raw description
        simplified_description: r.simplifiedDescription ?? null, // NEW
        amount: r.amount,
        balance: r.balance,
        currency: "EUR",
        category_id: r.category && categoryNameToId.has(r.category)
            ? categoryNameToId.get(r.category)!
            : null,
        raw_csv_row: JSON.stringify(metadata), // Store v2 metadata
        created_at: timestamp,
        updated_at: timestamp,
    };
});
```

---

### Step 9: Update UI Review Dialog

**File**: Modify `components/csv-review-dialog.tsx`

Add preview column for simplified descriptions:

```tsx
// In CSV review dialog, add column for simplified description
<TableHead>Simplified</TableHead>

// In table body
<TableCell className="font-medium text-sm">
    {row.simplifiedDescription || "-"}
</TableCell>
```

---

## Testing Plan

### Unit Tests

1. **Sanitization** (`__tests__/lib/sanitize-description.test.ts`)
   - ✅ Card number masking
   - ✅ IBAN masking
   - ✅ Phone number masking
   - ✅ Authorization code masking
   - ✅ Merchant token extraction

2. **Rule Simplification** (`__tests__/lib/rule-simplify.test.ts`)
   - ✅ Merchant matching
   - ✅ Transfer detection
   - ✅ Name extraction (with honorifics)
   - ✅ Operation detection (fee, ATM, salary, refund)
   - ✅ Fallback behavior

3. **AI Simplify** (`__tests__/lib/ai-simplify.test.ts`)
   - ✅ Batch processing
   - ✅ Response parsing
   - ✅ Error handling

4. **AI Categorize** (`__tests__/lib/ai-categorize.test.ts`)
   - ✅ Batch processing
   - ✅ Category validation
   - ✅ Confidence scoring

### Integration Tests

1. **Full Pipeline** (`__tests__/integration/import-pipeline-v2.test.ts`)
   - Upload CSV → Parse → Simplify → Categorize → Import
   - Verify DB columns populated
   - Verify metadata JSON structure
   - Test with 200-2000 transactions

### Manual Testing

1. **Real Data Testing**
   - Spanish bank statements (Santander, BBVA, CaixaBank)
   - Transfer scenarios (Bizum, SEPA)
   - Mixed merchants (known + unknown)

2. **Performance Testing**
   - Batch sizes (50, 100, 150 items)
   - Large imports (1000+ transactions)
   - Caching effectiveness

---

## Rollout Strategy

### Phase 1: Feature Flag (Week 1)
- Deploy with feature flag OFF
- Test in staging environment
- Monitor logs for errors

### Phase 2: Beta Testing (Week 2)
- Enable for beta users (10%)
- Monitor success rate
- Collect feedback

### Phase 3: Gradual Rollout (Week 3)
- 25% → 50% → 75% → 100%
- Monitor AI costs
- Track categorization accuracy

### Phase 4: Post-Launch (Week 4+)
- Analyze categorization improvements
- Refine merchant rules based on data
- Optimize batching and caching

---

## Success Metrics

1. **Categorization Accuracy**
   - Target: 90%+ accuracy (up from current ~75%)
   - Measure: Manual review of 1000 random transactions

2. **Simplification Quality**
   - Target: 85%+ meaningful simplifications
   - Measure: User feedback + manual review

3. **Performance**
   - Target: Import time \u003c 10s for 100 transactions
   - Target: AI cost \u003c $0.10 per 1000 transactions

4. **User Satisfaction**
   - Target: Reduce manual recategorization by 50%
   - Measure: Track recategorization events

---

## Migration Considerations

### Backward Compatibility

- ✅ Existing transactions without `simplified_description` continue to work
- ✅ UI falls back to raw `description` if `simplified_description` is null
- ✅ Manual categorization still works (takes precedence)

### Existing Data Migration (Optional)

If you want to backfill existing transactions:

```sql
-- Batch update existing transactions
-- Run during off-peak hours
UPDATE transactions
SET simplified_description = SUBSTRING(description, 1, 50)
WHERE simplified_description IS NULL
AND created_at < '2025-01-01'
LIMIT 10000;
```

**Recommendation**: Do NOT backfill. Only new imports use v2 pipeline.

---

## Open Questions & Decisions Needed

1. **Should we backfill existing transactions?**
   - Recommendation: NO (too expensive, old data less important)

2. **What should we do with the existing `summary` field in `TxRow`?**
   - Option A: Deprecate and remove
   - Option B: Keep both (use `summary` for display, `simplifiedDescription` for categorization)
   - Recommendation: Use `simplifiedDescription` everywhere, remove `summary`

3. **Should we expose simplified description in UI?**
   - Recommendation: YES (show in transaction tables, use for search)

4. **Should we add merchant filtering in UI?**
   - Recommendation: FUTURE ENHANCEMENT (filter by `simplified_description`)

---

## Next Steps

1. ✅ Review this plan with team
2. ⬜ Get approval for database migration
3. ⬜ Set up feature flag in environment
4. ⬜ Begin implementation (Phase 1: Foundation)
5. ⬜ Create tracking ticket for each step

---

**End of Implementation Plan**
